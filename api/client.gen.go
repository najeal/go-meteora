// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for OrderBy.
const (
	Asc  OrderBy = "asc"
	Desc OrderBy = "desc"
)

// Defines values for PairSortKey.
const (
	Feetvlratio PairSortKey = "feetvlratio"
	Lm          PairSortKey = "lm"
	Tvl         PairSortKey = "tvl"
	Volume      PairSortKey = "volume"
)

// AllGroupOfPairs defines model for AllGroupOfPairs.
type AllGroupOfPairs struct {
	Groups []PairGroup `json:"groups"`
	Total  int         `json:"total"`
}

// AllGroupOfPairsMetadata defines model for AllGroupOfPairsMetadata.
type AllGroupOfPairsMetadata struct {
	Metadatas []PairGroupMetadata `json:"metadatas"`
	Total     int                 `json:"total"`
}

// AllPairsWithPagination defines model for AllPairsWithPagination.
type AllPairsWithPagination struct {
	Pairs []PairInfo `json:"pairs"`
	Total int        `json:"total"`
}

// BinArrayCache defines model for BinArrayCache.
type BinArrayCache struct {
	// Address Address of the bin array
	Address string     `json:"address"`
	Bins    []BinCache `json:"bins"`

	// Index Index of the bin array
	Index int64 `json:"index"`
}

// BinCache defines model for BinCache.
type BinCache struct {
	// AmountX Amount of token X in the bin. This already excluded protocol fees.
	AmountX int64 `json:"amount_x"`

	// AmountXIn Total token X swap into the bin. Only used for tracking purpose.
	AmountXIn int `json:"amount_x_in"`

	// AmountY Amount of token Y in the bin. This already excluded protocol fees.
	AmountY int64 `json:"amount_y"`

	// AmountYIn Total token Y swap into he bin. Only used for tracking purpose.
	AmountYIn int `json:"amount_y_in"`

	// FeeAmountXPerTokenStored Swap fee amount of token X per liquidity deposited.
	FeeAmountXPerTokenStored int `json:"fee_amount_x_per_token_stored"`

	// FeeAmountYPerTokenStored Swap fee amount of token Y per liquidity deposited.
	FeeAmountYPerTokenStored int `json:"fee_amount_y_per_token_stored"`

	// LiquiditySupply Liquidities of the bin. This is the same as LP mint supply.
	LiquiditySupply int `json:"liquidity_supply"`

	// Price Bin price
	Price int `json:"price"`

	// RewardPerTokenStored reward_a_per_token_stored
	RewardPerTokenStored int `json:"reward_per_token_stored"`
}

// BinTradeVolume defines model for BinTradeVolume.
type BinTradeVolume struct {
	// BinId ID of the bin
	BinId int32 `json:"bin_id"`

	// TotalAmountUsd Total USD value swapped.
	TotalAmountUsd float32 `json:"total_amount_usd"`

	// TotalAmountX Total token X swapped.
	TotalAmountX string `json:"total_amount_x"`

	// TotalAmountY Total token Y swapped.
	TotalAmountY string `json:"total_amount_y"`
}

// ClaimFee defines model for ClaimFee.
type ClaimFee struct {
	// OnchainTimestamp Timestamp of the activity
	OnchainTimestamp int64 `json:"onchain_timestamp"`

	// PairAddress Address of the liquidity pair for the position
	PairAddress string `json:"pair_address"`

	// PositionAddress Address of the position
	PositionAddress string `json:"position_address"`

	// TokenXAmount Amount of token X
	TokenXAmount int64 `json:"token_x_amount"`

	// TokenXUsdAmount Amount of token X in USD
	TokenXUsdAmount float32 `json:"token_x_usd_amount"`

	// TokenYAmount Amount of token Y
	TokenYAmount int64 `json:"token_y_amount"`

	// TokenYUsdAmount Amount of token Y in USD
	TokenYUsdAmount float32 `json:"token_y_usd_amount"`

	// TxId Transaction hash
	TxId string `json:"tx_id"`
}

// ClaimReward defines model for ClaimReward.
type ClaimReward struct {
	// OnchainTimestamp Timestamp of the activity
	OnchainTimestamp int64 `json:"onchain_timestamp"`

	// PairAddress Address of the liquidity pair for the position
	PairAddress string `json:"pair_address"`

	// PositionAddress Address of the position
	PositionAddress string `json:"position_address"`

	// RewardMintAddress Address of the farm reward claimed
	RewardMintAddress string `json:"reward_mint_address"`

	// TokenAmount Amount of reward token claimed
	TokenAmount int64 `json:"token_amount"`

	// TokenUsdAmount Amount of reward token claimed in USD
	TokenUsdAmount float32 `json:"token_usd_amount"`

	// TxId Transaction hash
	TxId string `json:"tx_id"`
}

// DepositWithdraw defines model for DepositWithdraw.
type DepositWithdraw struct {
	// ActiveBinId Active bin ID
	ActiveBinId int64 `json:"active_bin_id"`

	// OnchainTimestamp Timestamp of the activity
	OnchainTimestamp int64 `json:"onchain_timestamp"`

	// PairAddress Address of the liquidity pair for the position
	PairAddress string `json:"pair_address"`

	// PositionAddress Address of the position
	PositionAddress string `json:"position_address"`

	// Price Liquidity pair price
	Price float32 `json:"price"`

	// TokenXAmount Amount of token X
	TokenXAmount int64 `json:"token_x_amount"`

	// TokenXUsdAmount Amount of token X in USD
	TokenXUsdAmount float32 `json:"token_x_usd_amount"`

	// TokenYAmount Amount of token Y
	TokenYAmount int64 `json:"token_y_amount"`

	// TokenYUsdAmount Amount of token Y in USD
	TokenYUsdAmount float32 `json:"token_y_usd_amount"`

	// TxId Transaction hash
	TxId string `json:"tx_id"`
}

// OrderBy defines model for OrderBy.
type OrderBy string

// PairFeeBps defines model for PairFeeBps.
type PairFeeBps struct {
	// AverageFeeBps Average fee charged in BPS
	AverageFeeBps float32 `json:"average_fee_bps"`

	// HourDate Date with hour information
	HourDate string `json:"hour_date"`

	// MaxFeeBps Maximum fee charged in BPS
	MaxFeeBps float32 `json:"max_fee_bps"`

	// MinFeeBps Minimum fee charged in BPS
	MinFeeBps float32 `json:"min_fee_bps"`

	// PairAddress Address of the liquidity pair
	PairAddress string `json:"pair_address"`
}

// PairGroup defines model for PairGroup.
type PairGroup struct {
	Name  string     `json:"name"`
	Pairs []PairInfo `json:"pairs"`
}

// PairGroupMetadata defines model for PairGroupMetadata.
type PairGroupMetadata struct {
	LexicalOrderMints string  `json:"lexical_order_mints"`
	MaxFeeTvlRatio    float32 `json:"max_fee_tvl_ratio"`
	MaxLmApr          float32 `json:"max_lm_apr"`
	MinFeeTvlRatio    float32 `json:"min_fee_tvl_ratio"`
	MinLmApr          float32 `json:"min_lm_apr"`
	Name              string  `json:"name"`
	TotalTradeVolume  float32 `json:"total_trade_volume"`
	TotalTvl          float32 `json:"total_tvl"`
}

// PairInfo defines model for PairInfo.
type PairInfo struct {
	// Address Address of the liquidity pair
	Address string `json:"address"`

	// Apr 24 hour APR
	Apr float32 `json:"apr"`

	// Apy 24 hour APY
	Apy float32 `json:"apy"`

	// BaseFeePercentage Base fee rate
	BaseFeePercentage string `json:"base_fee_percentage"`

	// BinStep Bin step
	BinStep int32 `json:"bin_step"`

	// CumulativeFeeVolume Cumulative fee volume
	CumulativeFeeVolume string `json:"cumulative_fee_volume"`

	// CumulativeTradeVolume Cumulative trading volume
	CumulativeTradeVolume string `json:"cumulative_trade_volume"`

	// CurrentPrice Price of the liquidity pair
	CurrentPrice float32 `json:"current_price"`

	// FarmApr Farm reward apr
	FarmApr float32 `json:"farm_apr"`

	// FarmApy Farm reward apy
	FarmApy float32 `json:"farm_apy"`

	// Fees24h Trading fees earned in the last 24 hours
	Fees24h float32 `json:"fees_24h"`

	// Hide Flag to indicate whether the pair should be shown in the UI
	Hide bool `json:"hide"`

	// Liquidity Total liquidity the liquidity pair holding. Also known as Total Value Locked
	Liquidity string `json:"liquidity"`

	// MaxFeePercentage Maximum fee rate
	MaxFeePercentage string `json:"max_fee_percentage"`

	// MintX Address of token X mint of the liquidity pair
	MintX string `json:"mint_x"`

	// MintY Address of token Y mint of the liquidity pair
	MintY string `json:"mint_y"`

	// Name Name of the liquidity pair
	Name string `json:"name"`

	// ProtocolFeePercentage Protocol fee rate. A cut from trade fee.
	ProtocolFeePercentage string `json:"protocol_fee_percentage"`

	// ReserveX Address of token X reserve of the liquidity pair
	ReserveX string `json:"reserve_x"`

	// ReserveXAmount Token X amount the liquidity pair hold
	ReserveXAmount int64 `json:"reserve_x_amount"`

	// ReserveY Address of token Y reserve of the liquidity pair
	ReserveY string `json:"reserve_y"`

	// ReserveYAmount Token Y amount the liquidity pair hold
	ReserveYAmount int64 `json:"reserve_y_amount"`

	// RewardMintX Address of the farming reward X of the liquidity pair
	RewardMintX string `json:"reward_mint_x"`

	// RewardMintY Address of the farming reward Y of the liquidity pair
	RewardMintY string `json:"reward_mint_y"`

	// TodayFees Trading fees earned since the beginning of the day
	TodayFees float32 `json:"today_fees"`

	// TradeVolume24h Trading volume in the last 24 hours
	TradeVolume24h float32 `json:"trade_volume_24h"`
}

// PairSortKey defines model for PairSortKey.
type PairSortKey string

// PairTradeVolume defines model for PairTradeVolume.
type PairTradeVolume struct {
	// DayDate Date with only day information
	DayDate string `json:"day_date"`

	// FeeVolume Total fee in USD
	FeeVolume float32 `json:"fee_volume"`

	// PairAddress Address of the liquidity pair
	PairAddress string `json:"pair_address"`

	// ProtocolFeeVolume Total protocol fee in USD
	ProtocolFeeVolume float32 `json:"protocol_fee_volume"`

	// TradeVolume Total trading volume in USD
	TradeVolume float32 `json:"trade_volume"`
}

// PairTvlSnapshotByDay defines model for PairTvlSnapshotByDay.
type PairTvlSnapshotByDay struct {
	// DayDate Date with only day information
	DayDate string `json:"day_date"`

	// PairAddress Address of the liquidity pair
	PairAddress string `json:"pair_address"`

	// TotalValueLocked Total value locked
	TotalValueLocked float32 `json:"total_value_locked"`
}

// Position defines model for Position.
type Position struct {
	// Address Address of the position
	Address string `json:"address"`

	// CreatedAt Created at utc timestamp
	CreatedAt string `json:"created_at"`

	// Owner Address of the position owner
	Owner string `json:"owner"`

	// PairAddress Address of the liquidity pair for the position
	PairAddress string `json:"pair_address"`

	// TotalFeeUsdClaimed Total fee has been claimed in USD
	TotalFeeUsdClaimed float32 `json:"total_fee_usd_claimed"`

	// TotalFeeXClaimed Total fee X has been claimed
	TotalFeeXClaimed int64 `json:"total_fee_x_claimed"`

	// TotalFeeYClaimed Total fee Y has been claimed
	TotalFeeYClaimed int64 `json:"total_fee_y_claimed"`

	// TotalRewardUsdClaimed Total farm reward has been claimed in USD
	TotalRewardUsdClaimed float32 `json:"total_reward_usd_claimed"`

	// TotalRewardXClaimed Total farm reward X has been claimed
	TotalRewardXClaimed int64 `json:"total_reward_x_claimed"`

	// TotalRewardYClaimed Total farm reward Y has been claimed
	TotalRewardYClaimed int64 `json:"total_reward_y_claimed"`
}

// PositionSnapshot defines model for PositionSnapshot.
type PositionSnapshot struct {
	// CreatedAt Created at
	CreatedAt string `json:"created_at"`

	// CumulativeFeeXAmount Accumulated fee X amount during the snapshot. This includes pending claimable fee.
	CumulativeFeeXAmount string `json:"cumulative_fee_x_amount"`

	// CumulativeFeeYAmount Accumulated fee Y amount during the snapshot. This includes pending claimable fee.
	CumulativeFeeYAmount string `json:"cumulative_fee_y_amount"`

	// CumulativeRewardXAmount Accumulated reward X amount during the snapshot. This includes pending claimable reward.
	CumulativeRewardXAmount string `json:"cumulative_reward_x_amount"`

	// CumulativeRewardYAmount Accumulated reward Y amount during the snapshot. This includes pending claimable reward.
	CumulativeRewardYAmount string `json:"cumulative_reward_y_amount"`

	// Id ID
	Id int64 `json:"id"`

	// PendingFeeXAmount Amount of pending claimable fee X during the snapshot
	PendingFeeXAmount int64 `json:"pending_fee_x_amount"`

	// PendingFeeYAmount Amount of pending claimable fee Y during the snapshot
	PendingFeeYAmount int64 `json:"pending_fee_y_amount"`

	// PendingRewardXAmount Amount of pending claimable reward X during the snapshot
	PendingRewardXAmount int64 `json:"pending_reward_x_amount"`

	// PendingRewardYAmount Amount of pending claimable reward Y during the snapshot
	PendingRewardYAmount int64 `json:"pending_reward_y_amount"`

	// PositionAddress Address of the position
	PositionAddress string `json:"position_address"`

	// RewardXUsdRate Reward X usd rate during the snapshot
	RewardXUsdRate float32 `json:"reward_x_usd_rate"`

	// RewardYUsdRate Reward Y usd rate during the snapshot
	RewardYUsdRate float32 `json:"reward_y_usd_rate"`

	// TokenXAmount Amount of token X the position is holding during the snapshot
	TokenXAmount int64 `json:"token_x_amount"`

	// TokenXUsdRate Token X usd rate during the snapshot
	TokenXUsdRate float32 `json:"token_x_usd_rate"`

	// TokenYAmount Amount of token Y the position is holding during the snapshot
	TokenYAmount int64 `json:"token_y_amount"`

	// TokenYUsdRate Token Y usd rate during the snapshot
	TokenYUsdRate float32 `json:"token_y_usd_rate"`
}

// PositionWithApy defines model for PositionWithApy.
type PositionWithApy struct {
	// Address Address of the position
	Address       string  `json:"address"`
	DailyFeeYield float32 `json:"daily_fee_yield"`
	FeeApr24h     float32 `json:"fee_apr_24h"`
	FeeApy24h     float32 `json:"fee_apy_24h"`

	// Owner Address of the position owner
	Owner string `json:"owner"`

	// PairAddress Address of the liquidity pair for the position
	PairAddress string `json:"pair_address"`

	// TotalFeeUsdClaimed Total fee has been claimed in USD
	TotalFeeUsdClaimed float32 `json:"total_fee_usd_claimed"`

	// TotalFeeXClaimed Total fee X has been claimed
	TotalFeeXClaimed int64 `json:"total_fee_x_claimed"`

	// TotalFeeYClaimed Total fee Y has been claimed
	TotalFeeYClaimed int64 `json:"total_fee_y_claimed"`

	// TotalRewardUsdClaimed Total farm reward has been claimed in USD
	TotalRewardUsdClaimed float32 `json:"total_reward_usd_claimed"`

	// TotalRewardXClaimed Total farm reward X has been claimed
	TotalRewardXClaimed int64 `json:"total_reward_x_claimed"`

	// TotalRewardYClaimed Total farm reward Y has been claimed
	TotalRewardYClaimed int64 `json:"total_reward_y_claimed"`
}

// ProtocolMetrics defines model for ProtocolMetrics.
type ProtocolMetrics struct {
	// DailyFee Daily trading fee
	DailyFee float32 `json:"daily_fee"`

	// DailyTradeVolume Daily trading volume
	DailyTradeVolume float32 `json:"daily_trade_volume"`

	// TotalFee Total trading fee
	TotalFee float32 `json:"total_fee"`

	// TotalTradeVolume Total trading volume
	TotalTradeVolume float32 `json:"total_trade_volume"`

	// TotalTvl Total value locked
	TotalTvl float32 `json:"total_tvl"`
}

// Swap defines model for Swap.
type Swap struct {
	// BinCount Number of bin involved
	BinCount int64 `json:"bin_count"`

	// EndBinId Ending bin ID for the swap
	EndBinId int64 `json:"end_bin_id"`

	// FeeBps Fee in BPS
	FeeBps float32 `json:"fee_bps"`

	// InAmount Amount of token swapped in
	InAmount int64 `json:"in_amount"`

	// InAmountUsd Amount of USD value swapped in
	InAmountUsd float32 `json:"in_amount_usd"`

	// InToken Address of the token swapped in
	InToken string `json:"in_token"`

	// OnchainTimestamp Timestamp of the swap activity
	OnchainTimestamp int64 `json:"onchain_timestamp"`

	// OutAmount Amount of token swapped out
	OutAmount int64 `json:"out_amount"`

	// OutAmountUsd Amount of USD value swapped out
	OutAmountUsd float32 `json:"out_amount_usd"`

	// OutToken Address of the token swapped out
	OutToken string `json:"out_token"`

	// PairAddress Address of the liquidity pair
	PairAddress string `json:"pair_address"`

	// ProtocolFee Amount of protocol fee charged
	ProtocolFee int64 `json:"protocol_fee"`

	// ProtocolFeeUsd Amount of protocol fee charged in USD
	ProtocolFeeUsd float32 `json:"protocol_fee_usd"`

	// StartBinId Starting bin ID for the swap
	StartBinId int64 `json:"start_bin_id"`

	// TradeFee Amount of fee charged
	TradeFee int64 `json:"trade_fee"`

	// TradeFeeUsd Amount of fee charged in USD
	TradeFeeUsd float32 `json:"trade_fee_usd"`

	// TxId Transaction hash
	TxId string `json:"tx_id"`
}

// WalletEarning defines model for WalletEarning.
type WalletEarning struct {
	// TotalFeeUsdClaimed Total fee amount has been claimed by the wallet in USD
	TotalFeeUsdClaimed *float32 `json:"total_fee_usd_claimed,omitempty"`

	// TotalFeeXClaimed Total fee x has been claimed by the wallet
	TotalFeeXClaimed *string `json:"total_fee_x_claimed,omitempty"`

	// TotalFeeYClaimed Total fee y has been claimed by the wallet
	TotalFeeYClaimed *string `json:"total_fee_y_claimed,omitempty"`

	// TotalRewardUsdClaimed Total farm reward amount has been claimed by the wallet in USD
	TotalRewardUsdClaimed *float32 `json:"total_reward_usd_claimed,omitempty"`

	// TotalRewardXClaimed Total reward x has been claimed by the wallet
	TotalRewardXClaimed *string `json:"total_reward_x_claimed,omitempty"`

	// TotalRewardYClaimed Total reward y has been claimed by the wallet
	TotalRewardYClaimed *string `json:"total_reward_y_claimed,omitempty"`
}

// AllParams defines parameters for All.
type AllParams struct {
	// IncludeUnknown Include pool with unverified token. Default true.
	IncludeUnknown *bool `form:"include_unknown,omitempty" json:"include_unknown,omitempty"`
}

// AllByGroupsParams defines parameters for AllByGroups.
type AllByGroupsParams struct {
	// Page Default is 0
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Default is 50
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipSize Default is 0
	SkipSize *int `form:"skip_size,omitempty" json:"skip_size,omitempty"`

	// PoolsToTop Pools to be sorted to top
	PoolsToTop *[]string `form:"pools_to_top,omitempty" json:"pools_to_top,omitempty"`

	// SortKey Sort key. Default is Volume.
	SortKey *PairSortKey `form:"sort_key,omitempty" json:"sort_key,omitempty"`

	// OrderBy Sort order. Default is Descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// SearchTerm Search term.
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`

	// IncludeUnknown Include pool with unverified token. Default true.
	IncludeUnknown *bool `form:"include_unknown,omitempty" json:"include_unknown,omitempty"`
}

// AllByGroupsMetadataParams defines parameters for AllByGroupsMetadata.
type AllByGroupsMetadataParams struct {
	// Page Default is 0
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Default is 50
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipSize Default is 0
	SkipSize *int `form:"skip_size,omitempty" json:"skip_size,omitempty"`

	// PoolsToTop Pools to be sorted to top
	PoolsToTop *[]string `form:"pools_to_top,omitempty" json:"pools_to_top,omitempty"`

	// SortKey Sort key. Default is Volume.
	SortKey *PairSortKey `form:"sort_key,omitempty" json:"sort_key,omitempty"`

	// OrderBy Sort order. Default is Descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// SearchTerm Search term.
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`

	// IncludeUnknown Include pool with unverified token. Default true.
	IncludeUnknown *bool `form:"include_unknown,omitempty" json:"include_unknown,omitempty"`
}

// AllWithPaginationParams defines parameters for AllWithPagination.
type AllWithPaginationParams struct {
	// Page Default is 0
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit Default is 50
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// SkipSize Default is 0
	SkipSize *int `form:"skip_size,omitempty" json:"skip_size,omitempty"`

	// PoolsToTop Pools to be sorted to top
	PoolsToTop *[]string `form:"pools_to_top,omitempty" json:"pools_to_top,omitempty"`

	// SortKey Sort key. Default is Volume.
	SortKey *PairSortKey `form:"sort_key,omitempty" json:"sort_key,omitempty"`

	// OrderBy Sort order. Default is Descending.
	OrderBy *OrderBy `form:"order_by,omitempty" json:"order_by,omitempty"`

	// SearchTerm Search term.
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`

	// IncludeUnknown Include pool with unverified token. Default true.
	IncludeUnknown *bool `form:"include_unknown,omitempty" json:"include_unknown,omitempty"`
}

// GetBinTradeVolumeByDaysParams defines parameters for GetBinTradeVolumeByDays.
type GetBinTradeVolumeByDaysParams struct {
	// NumOfDays Number of days before today. Max 255.
	NumOfDays int32 `form:"num_of_days" json:"num_of_days"`
}

// GetPairFeeBpsByDaysParams defines parameters for GetPairFeeBpsByDays.
type GetPairFeeBpsByDaysParams struct {
	// NumOfDays Number of days before today. Max 255.
	NumOfDays int32 `form:"num_of_days" json:"num_of_days"`
}

// GetPairDailyTradeVolumeByDaysParams defines parameters for GetPairDailyTradeVolumeByDays.
type GetPairDailyTradeVolumeByDaysParams struct {
	// NumOfDays Number of days before today. Max 255.
	NumOfDays int32 `form:"num_of_days" json:"num_of_days"`
}

// GetPairTvlByDaysParams defines parameters for GetPairTvlByDays.
type GetPairTvlByDaysParams struct {
	// NumOfDays Number of days before today. Max 255.
	NumOfDays int32 `form:"num_of_days" json:"num_of_days"`
}

// GetPairSwapRecordsParams defines parameters for GetPairSwapRecords.
type GetPairSwapRecordsParams struct {
	// RowsToTake Number of records to take. Max 255.
	RowsToTake int32 `form:"rows_to_take" json:"rows_to_take"`
}

// GetRecentNSnapshotParams defines parameters for GetRecentNSnapshot.
type GetRecentNSnapshotParams struct {
	// RowsToTake Number of records to take. Max 255.
	RowsToTake int32 `form:"rows_to_take" json:"rows_to_take"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetProtocolMetrics request
	GetProtocolMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// All request
	All(ctx context.Context, params *AllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllByGroups request
	AllByGroups(ctx context.Context, params *AllByGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllByGroupsMetadata request
	AllByGroupsMetadata(ctx context.Context, params *AllByGroupsMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AllWithPagination request
	AllWithPagination(ctx context.Context, params *AllWithPaginationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSingleGroupPair request
	GetSingleGroupPair(ctx context.Context, lexicalOrderMints string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPair request
	GetPair(ctx context.Context, pairAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBinTradeVolumeByDays request
	GetBinTradeVolumeByDays(ctx context.Context, pairAddress string, params *GetBinTradeVolumeByDaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPairFeeBpsByDays request
	GetPairFeeBpsByDays(ctx context.Context, pairAddress string, params *GetPairFeeBpsByDaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPairDailyTradeVolumeByDays request
	GetPairDailyTradeVolumeByDays(ctx context.Context, pairAddress string, params *GetPairDailyTradeVolumeByDaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPairTvlByDays request
	GetPairTvlByDays(ctx context.Context, pairAddress string, params *GetPairTvlByDaysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPairSwapRecords request
	GetPairSwapRecords(ctx context.Context, pairAddress string, params *GetPairSwapRecordsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBinArrays request
	GetBinArrays(ctx context.Context, pairAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPosition request
	GetPosition(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClaimFees request
	GetClaimFees(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClaimRewards request
	GetClaimRewards(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeposits request
	GetDeposits(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecentNSnapshot request
	GetRecentNSnapshot(ctx context.Context, positionAddress string, params *GetRecentNSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWithdraws request
	GetWithdraws(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPositionV2 request
	GetPositionV2(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWalletEarning request
	GetWalletEarning(ctx context.Context, walletAddress string, pairAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetProtocolMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProtocolMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) All(ctx context.Context, params *AllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllByGroups(ctx context.Context, params *AllByGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllByGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllByGroupsMetadata(ctx context.Context, params *AllByGroupsMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllByGroupsMetadataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AllWithPagination(ctx context.Context, params *AllWithPaginationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAllWithPaginationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSingleGroupPair(ctx context.Context, lexicalOrderMints string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSingleGroupPairRequest(c.Server, lexicalOrderMints)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPair(ctx context.Context, pairAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPairRequest(c.Server, pairAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBinTradeVolumeByDays(ctx context.Context, pairAddress string, params *GetBinTradeVolumeByDaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBinTradeVolumeByDaysRequest(c.Server, pairAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPairFeeBpsByDays(ctx context.Context, pairAddress string, params *GetPairFeeBpsByDaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPairFeeBpsByDaysRequest(c.Server, pairAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPairDailyTradeVolumeByDays(ctx context.Context, pairAddress string, params *GetPairDailyTradeVolumeByDaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPairDailyTradeVolumeByDaysRequest(c.Server, pairAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPairTvlByDays(ctx context.Context, pairAddress string, params *GetPairTvlByDaysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPairTvlByDaysRequest(c.Server, pairAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPairSwapRecords(ctx context.Context, pairAddress string, params *GetPairSwapRecordsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPairSwapRecordsRequest(c.Server, pairAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBinArrays(ctx context.Context, pairAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBinArraysRequest(c.Server, pairAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPosition(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPositionRequest(c.Server, positionAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClaimFees(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClaimFeesRequest(c.Server, positionAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClaimRewards(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClaimRewardsRequest(c.Server, positionAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeposits(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDepositsRequest(c.Server, positionAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecentNSnapshot(ctx context.Context, positionAddress string, params *GetRecentNSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecentNSnapshotRequest(c.Server, positionAddress, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWithdraws(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWithdrawsRequest(c.Server, positionAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPositionV2(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPositionV2Request(c.Server, positionAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWalletEarning(ctx context.Context, walletAddress string, pairAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWalletEarningRequest(c.Server, walletAddress, pairAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetProtocolMetricsRequest generates requests for GetProtocolMetrics
func NewGetProtocolMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/info/protocol_metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllRequest generates requests for All
func NewAllRequest(server string, params *AllParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeUnknown != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_unknown", runtime.ParamLocationQuery, *params.IncludeUnknown); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllByGroupsRequest generates requests for AllByGroups
func NewAllByGroupsRequest(server string, params *AllByGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/all_by_groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_size", runtime.ParamLocationQuery, *params.SkipSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PoolsToTop != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pools_to_top", runtime.ParamLocationQuery, *params.PoolsToTop); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_key", runtime.ParamLocationQuery, *params.SortKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeUnknown != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_unknown", runtime.ParamLocationQuery, *params.IncludeUnknown); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllByGroupsMetadataRequest generates requests for AllByGroupsMetadata
func NewAllByGroupsMetadataRequest(server string, params *AllByGroupsMetadataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/all_by_groups_metadata")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_size", runtime.ParamLocationQuery, *params.SkipSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PoolsToTop != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pools_to_top", runtime.ParamLocationQuery, *params.PoolsToTop); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_key", runtime.ParamLocationQuery, *params.SortKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeUnknown != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_unknown", runtime.ParamLocationQuery, *params.IncludeUnknown); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAllWithPaginationRequest generates requests for AllWithPagination
func NewAllWithPaginationRequest(server string, params *AllWithPaginationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/all_with_pagination")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_size", runtime.ParamLocationQuery, *params.SkipSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PoolsToTop != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pools_to_top", runtime.ParamLocationQuery, *params.PoolsToTop); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortKey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort_key", runtime.ParamLocationQuery, *params.SortKey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchTerm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeUnknown != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_unknown", runtime.ParamLocationQuery, *params.IncludeUnknown); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSingleGroupPairRequest generates requests for GetSingleGroupPair
func NewGetSingleGroupPairRequest(server string, lexicalOrderMints string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "lexical_order_mints", runtime.ParamLocationPath, lexicalOrderMints)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/group_pair/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPairRequest generates requests for GetPair
func NewGetPairRequest(server string, pairAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pair_address", runtime.ParamLocationPath, pairAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}
fmt.Println(queryURL.String())
	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBinTradeVolumeByDaysRequest generates requests for GetBinTradeVolumeByDays
func NewGetBinTradeVolumeByDaysRequest(server string, pairAddress string, params *GetBinTradeVolumeByDaysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pair_address", runtime.ParamLocationPath, pairAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/%s/analytic/bin_trade_volume", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "num_of_days", runtime.ParamLocationQuery, params.NumOfDays); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPairFeeBpsByDaysRequest generates requests for GetPairFeeBpsByDays
func NewGetPairFeeBpsByDaysRequest(server string, pairAddress string, params *GetPairFeeBpsByDaysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pair_address", runtime.ParamLocationPath, pairAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/%s/analytic/pair_fee_bps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "num_of_days", runtime.ParamLocationQuery, params.NumOfDays); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPairDailyTradeVolumeByDaysRequest generates requests for GetPairDailyTradeVolumeByDays
func NewGetPairDailyTradeVolumeByDaysRequest(server string, pairAddress string, params *GetPairDailyTradeVolumeByDaysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pair_address", runtime.ParamLocationPath, pairAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/%s/analytic/pair_trade_volume", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "num_of_days", runtime.ParamLocationQuery, params.NumOfDays); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPairTvlByDaysRequest generates requests for GetPairTvlByDays
func NewGetPairTvlByDaysRequest(server string, pairAddress string, params *GetPairTvlByDaysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pair_address", runtime.ParamLocationPath, pairAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/%s/analytic/pair_tvl", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "num_of_days", runtime.ParamLocationQuery, params.NumOfDays); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPairSwapRecordsRequest generates requests for GetPairSwapRecords
func NewGetPairSwapRecordsRequest(server string, pairAddress string, params *GetPairSwapRecordsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pair_address", runtime.ParamLocationPath, pairAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/%s/analytic/swap_history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rows_to_take", runtime.ParamLocationQuery, params.RowsToTake); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBinArraysRequest generates requests for GetBinArrays
func NewGetBinArraysRequest(server string, pairAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pair_address", runtime.ParamLocationPath, pairAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/pair/%s/bin_arrays", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPositionRequest generates requests for GetPosition
func NewGetPositionRequest(server string, positionAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "position_address", runtime.ParamLocationPath, positionAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/position/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClaimFeesRequest generates requests for GetClaimFees
func NewGetClaimFeesRequest(server string, positionAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "position_address", runtime.ParamLocationPath, positionAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/position/%s/claim_fees", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClaimRewardsRequest generates requests for GetClaimRewards
func NewGetClaimRewardsRequest(server string, positionAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "position_address", runtime.ParamLocationPath, positionAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/position/%s/claim_rewards", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDepositsRequest generates requests for GetDeposits
func NewGetDepositsRequest(server string, positionAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "position_address", runtime.ParamLocationPath, positionAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/position/%s/deposits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecentNSnapshotRequest generates requests for GetRecentNSnapshot
func NewGetRecentNSnapshotRequest(server string, positionAddress string, params *GetRecentNSnapshotParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "position_address", runtime.ParamLocationPath, positionAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/position/%s/snapshots", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rows_to_take", runtime.ParamLocationQuery, params.RowsToTake); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWithdrawsRequest generates requests for GetWithdraws
func NewGetWithdrawsRequest(server string, positionAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "position_address", runtime.ParamLocationPath, positionAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/position/%s/withdraws", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPositionV2Request generates requests for GetPositionV2
func NewGetPositionV2Request(server string, positionAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "position_address", runtime.ParamLocationPath, positionAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/position_v2/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWalletEarningRequest generates requests for GetWalletEarning
func NewGetWalletEarningRequest(server string, walletAddress string, pairAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wallet_address", runtime.ParamLocationPath, walletAddress)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pair_address", runtime.ParamLocationPath, pairAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/wallet/%s/%s/earning", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetProtocolMetricsWithResponse request
	GetProtocolMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProtocolMetricsResponse, error)

	// AllWithResponse request
	AllWithResponse(ctx context.Context, params *AllParams, reqEditors ...RequestEditorFn) (*AllResponse, error)

	// AllByGroupsWithResponse request
	AllByGroupsWithResponse(ctx context.Context, params *AllByGroupsParams, reqEditors ...RequestEditorFn) (*AllByGroupsResponse, error)

	// AllByGroupsMetadataWithResponse request
	AllByGroupsMetadataWithResponse(ctx context.Context, params *AllByGroupsMetadataParams, reqEditors ...RequestEditorFn) (*AllByGroupsMetadataResponse, error)

	// AllWithPaginationWithResponse request
	AllWithPaginationWithResponse(ctx context.Context, params *AllWithPaginationParams, reqEditors ...RequestEditorFn) (*AllWithPaginationResponse, error)

	// GetSingleGroupPairWithResponse request
	GetSingleGroupPairWithResponse(ctx context.Context, lexicalOrderMints string, reqEditors ...RequestEditorFn) (*GetSingleGroupPairResponse, error)

	// GetPairWithResponse request
	GetPairWithResponse(ctx context.Context, pairAddress string, reqEditors ...RequestEditorFn) (*GetPairResponse, error)

	// GetBinTradeVolumeByDaysWithResponse request
	GetBinTradeVolumeByDaysWithResponse(ctx context.Context, pairAddress string, params *GetBinTradeVolumeByDaysParams, reqEditors ...RequestEditorFn) (*GetBinTradeVolumeByDaysResponse, error)

	// GetPairFeeBpsByDaysWithResponse request
	GetPairFeeBpsByDaysWithResponse(ctx context.Context, pairAddress string, params *GetPairFeeBpsByDaysParams, reqEditors ...RequestEditorFn) (*GetPairFeeBpsByDaysResponse, error)

	// GetPairDailyTradeVolumeByDaysWithResponse request
	GetPairDailyTradeVolumeByDaysWithResponse(ctx context.Context, pairAddress string, params *GetPairDailyTradeVolumeByDaysParams, reqEditors ...RequestEditorFn) (*GetPairDailyTradeVolumeByDaysResponse, error)

	// GetPairTvlByDaysWithResponse request
	GetPairTvlByDaysWithResponse(ctx context.Context, pairAddress string, params *GetPairTvlByDaysParams, reqEditors ...RequestEditorFn) (*GetPairTvlByDaysResponse, error)

	// GetPairSwapRecordsWithResponse request
	GetPairSwapRecordsWithResponse(ctx context.Context, pairAddress string, params *GetPairSwapRecordsParams, reqEditors ...RequestEditorFn) (*GetPairSwapRecordsResponse, error)

	// GetBinArraysWithResponse request
	GetBinArraysWithResponse(ctx context.Context, pairAddress string, reqEditors ...RequestEditorFn) (*GetBinArraysResponse, error)

	// GetPositionWithResponse request
	GetPositionWithResponse(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*GetPositionResponse, error)

	// GetClaimFeesWithResponse request
	GetClaimFeesWithResponse(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*GetClaimFeesResponse, error)

	// GetClaimRewardsWithResponse request
	GetClaimRewardsWithResponse(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*GetClaimRewardsResponse, error)

	// GetDepositsWithResponse request
	GetDepositsWithResponse(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*GetDepositsResponse, error)

	// GetRecentNSnapshotWithResponse request
	GetRecentNSnapshotWithResponse(ctx context.Context, positionAddress string, params *GetRecentNSnapshotParams, reqEditors ...RequestEditorFn) (*GetRecentNSnapshotResponse, error)

	// GetWithdrawsWithResponse request
	GetWithdrawsWithResponse(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*GetWithdrawsResponse, error)

	// GetPositionV2WithResponse request
	GetPositionV2WithResponse(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*GetPositionV2Response, error)

	// GetWalletEarningWithResponse request
	GetWalletEarningWithResponse(ctx context.Context, walletAddress string, pairAddress string, reqEditors ...RequestEditorFn) (*GetWalletEarningResponse, error)
}

type GetProtocolMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ProtocolMetrics
}

// Status returns HTTPResponse.Status
func (r GetProtocolMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProtocolMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PairInfo
}

// Status returns HTTPResponse.Status
func (r AllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllByGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllGroupOfPairs
}

// Status returns HTTPResponse.Status
func (r AllByGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllByGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllByGroupsMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllGroupOfPairsMetadata
}

// Status returns HTTPResponse.Status
func (r AllByGroupsMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllByGroupsMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AllWithPaginationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllPairsWithPagination
}

// Status returns HTTPResponse.Status
func (r AllWithPaginationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AllWithPaginationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSingleGroupPairResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PairInfo
}

// Status returns HTTPResponse.Status
func (r GetSingleGroupPairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSingleGroupPairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPairResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PairInfo
}

// Status returns HTTPResponse.Status
func (r GetPairResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPairResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBinTradeVolumeByDaysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BinTradeVolume
}

// Status returns HTTPResponse.Status
func (r GetBinTradeVolumeByDaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBinTradeVolumeByDaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPairFeeBpsByDaysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PairFeeBps
}

// Status returns HTTPResponse.Status
func (r GetPairFeeBpsByDaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPairFeeBpsByDaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPairDailyTradeVolumeByDaysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PairTradeVolume
}

// Status returns HTTPResponse.Status
func (r GetPairDailyTradeVolumeByDaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPairDailyTradeVolumeByDaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPairTvlByDaysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PairTvlSnapshotByDay
}

// Status returns HTTPResponse.Status
func (r GetPairTvlByDaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPairTvlByDaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPairSwapRecordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Swap
}

// Status returns HTTPResponse.Status
func (r GetPairSwapRecordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPairSwapRecordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBinArraysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BinArrayCache
}

// Status returns HTTPResponse.Status
func (r GetBinArraysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBinArraysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PositionWithApy
}

// Status returns HTTPResponse.Status
func (r GetPositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClaimFeesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClaimFee
}

// Status returns HTTPResponse.Status
func (r GetClaimFeesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClaimFeesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClaimRewardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClaimReward
}

// Status returns HTTPResponse.Status
func (r GetClaimRewardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClaimRewardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDepositsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DepositWithdraw
}

// Status returns HTTPResponse.Status
func (r GetDepositsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDepositsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecentNSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PositionSnapshot
}

// Status returns HTTPResponse.Status
func (r GetRecentNSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecentNSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWithdrawsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DepositWithdraw
}

// Status returns HTTPResponse.Status
func (r GetWithdrawsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWithdrawsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPositionV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Position
}

// Status returns HTTPResponse.Status
func (r GetPositionV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPositionV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWalletEarningResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WalletEarning
}

// Status returns HTTPResponse.Status
func (r GetWalletEarningResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWalletEarningResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetProtocolMetricsWithResponse request returning *GetProtocolMetricsResponse
func (c *ClientWithResponses) GetProtocolMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetProtocolMetricsResponse, error) {
	rsp, err := c.GetProtocolMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProtocolMetricsResponse(rsp)
}

// AllWithResponse request returning *AllResponse
func (c *ClientWithResponses) AllWithResponse(ctx context.Context, params *AllParams, reqEditors ...RequestEditorFn) (*AllResponse, error) {
	rsp, err := c.All(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllResponse(rsp)
}

// AllByGroupsWithResponse request returning *AllByGroupsResponse
func (c *ClientWithResponses) AllByGroupsWithResponse(ctx context.Context, params *AllByGroupsParams, reqEditors ...RequestEditorFn) (*AllByGroupsResponse, error) {
	rsp, err := c.AllByGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllByGroupsResponse(rsp)
}

// AllByGroupsMetadataWithResponse request returning *AllByGroupsMetadataResponse
func (c *ClientWithResponses) AllByGroupsMetadataWithResponse(ctx context.Context, params *AllByGroupsMetadataParams, reqEditors ...RequestEditorFn) (*AllByGroupsMetadataResponse, error) {
	rsp, err := c.AllByGroupsMetadata(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllByGroupsMetadataResponse(rsp)
}

// AllWithPaginationWithResponse request returning *AllWithPaginationResponse
func (c *ClientWithResponses) AllWithPaginationWithResponse(ctx context.Context, params *AllWithPaginationParams, reqEditors ...RequestEditorFn) (*AllWithPaginationResponse, error) {
	rsp, err := c.AllWithPagination(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAllWithPaginationResponse(rsp)
}

// GetSingleGroupPairWithResponse request returning *GetSingleGroupPairResponse
func (c *ClientWithResponses) GetSingleGroupPairWithResponse(ctx context.Context, lexicalOrderMints string, reqEditors ...RequestEditorFn) (*GetSingleGroupPairResponse, error) {
	rsp, err := c.GetSingleGroupPair(ctx, lexicalOrderMints, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSingleGroupPairResponse(rsp)
}

// GetPairWithResponse request returning *GetPairResponse
func (c *ClientWithResponses) GetPairWithResponse(ctx context.Context, pairAddress string, reqEditors ...RequestEditorFn) (*GetPairResponse, error) {
	rsp, err := c.GetPair(ctx, pairAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPairResponse(rsp)
}

// GetBinTradeVolumeByDaysWithResponse request returning *GetBinTradeVolumeByDaysResponse
func (c *ClientWithResponses) GetBinTradeVolumeByDaysWithResponse(ctx context.Context, pairAddress string, params *GetBinTradeVolumeByDaysParams, reqEditors ...RequestEditorFn) (*GetBinTradeVolumeByDaysResponse, error) {
	rsp, err := c.GetBinTradeVolumeByDays(ctx, pairAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBinTradeVolumeByDaysResponse(rsp)
}

// GetPairFeeBpsByDaysWithResponse request returning *GetPairFeeBpsByDaysResponse
func (c *ClientWithResponses) GetPairFeeBpsByDaysWithResponse(ctx context.Context, pairAddress string, params *GetPairFeeBpsByDaysParams, reqEditors ...RequestEditorFn) (*GetPairFeeBpsByDaysResponse, error) {
	rsp, err := c.GetPairFeeBpsByDays(ctx, pairAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPairFeeBpsByDaysResponse(rsp)
}

// GetPairDailyTradeVolumeByDaysWithResponse request returning *GetPairDailyTradeVolumeByDaysResponse
func (c *ClientWithResponses) GetPairDailyTradeVolumeByDaysWithResponse(ctx context.Context, pairAddress string, params *GetPairDailyTradeVolumeByDaysParams, reqEditors ...RequestEditorFn) (*GetPairDailyTradeVolumeByDaysResponse, error) {
	rsp, err := c.GetPairDailyTradeVolumeByDays(ctx, pairAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPairDailyTradeVolumeByDaysResponse(rsp)
}

// GetPairTvlByDaysWithResponse request returning *GetPairTvlByDaysResponse
func (c *ClientWithResponses) GetPairTvlByDaysWithResponse(ctx context.Context, pairAddress string, params *GetPairTvlByDaysParams, reqEditors ...RequestEditorFn) (*GetPairTvlByDaysResponse, error) {
	rsp, err := c.GetPairTvlByDays(ctx, pairAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPairTvlByDaysResponse(rsp)
}

// GetPairSwapRecordsWithResponse request returning *GetPairSwapRecordsResponse
func (c *ClientWithResponses) GetPairSwapRecordsWithResponse(ctx context.Context, pairAddress string, params *GetPairSwapRecordsParams, reqEditors ...RequestEditorFn) (*GetPairSwapRecordsResponse, error) {
	rsp, err := c.GetPairSwapRecords(ctx, pairAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPairSwapRecordsResponse(rsp)
}

// GetBinArraysWithResponse request returning *GetBinArraysResponse
func (c *ClientWithResponses) GetBinArraysWithResponse(ctx context.Context, pairAddress string, reqEditors ...RequestEditorFn) (*GetBinArraysResponse, error) {
	rsp, err := c.GetBinArrays(ctx, pairAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBinArraysResponse(rsp)
}

// GetPositionWithResponse request returning *GetPositionResponse
func (c *ClientWithResponses) GetPositionWithResponse(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*GetPositionResponse, error) {
	rsp, err := c.GetPosition(ctx, positionAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPositionResponse(rsp)
}

// GetClaimFeesWithResponse request returning *GetClaimFeesResponse
func (c *ClientWithResponses) GetClaimFeesWithResponse(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*GetClaimFeesResponse, error) {
	rsp, err := c.GetClaimFees(ctx, positionAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClaimFeesResponse(rsp)
}

// GetClaimRewardsWithResponse request returning *GetClaimRewardsResponse
func (c *ClientWithResponses) GetClaimRewardsWithResponse(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*GetClaimRewardsResponse, error) {
	rsp, err := c.GetClaimRewards(ctx, positionAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClaimRewardsResponse(rsp)
}

// GetDepositsWithResponse request returning *GetDepositsResponse
func (c *ClientWithResponses) GetDepositsWithResponse(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*GetDepositsResponse, error) {
	rsp, err := c.GetDeposits(ctx, positionAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDepositsResponse(rsp)
}

// GetRecentNSnapshotWithResponse request returning *GetRecentNSnapshotResponse
func (c *ClientWithResponses) GetRecentNSnapshotWithResponse(ctx context.Context, positionAddress string, params *GetRecentNSnapshotParams, reqEditors ...RequestEditorFn) (*GetRecentNSnapshotResponse, error) {
	rsp, err := c.GetRecentNSnapshot(ctx, positionAddress, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecentNSnapshotResponse(rsp)
}

// GetWithdrawsWithResponse request returning *GetWithdrawsResponse
func (c *ClientWithResponses) GetWithdrawsWithResponse(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*GetWithdrawsResponse, error) {
	rsp, err := c.GetWithdraws(ctx, positionAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWithdrawsResponse(rsp)
}

// GetPositionV2WithResponse request returning *GetPositionV2Response
func (c *ClientWithResponses) GetPositionV2WithResponse(ctx context.Context, positionAddress string, reqEditors ...RequestEditorFn) (*GetPositionV2Response, error) {
	rsp, err := c.GetPositionV2(ctx, positionAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPositionV2Response(rsp)
}

// GetWalletEarningWithResponse request returning *GetWalletEarningResponse
func (c *ClientWithResponses) GetWalletEarningWithResponse(ctx context.Context, walletAddress string, pairAddress string, reqEditors ...RequestEditorFn) (*GetWalletEarningResponse, error) {
	rsp, err := c.GetWalletEarning(ctx, walletAddress, pairAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWalletEarningResponse(rsp)
}

// ParseGetProtocolMetricsResponse parses an HTTP response from a GetProtocolMetricsWithResponse call
func ParseGetProtocolMetricsResponse(rsp *http.Response) (*GetProtocolMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProtocolMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProtocolMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAllResponse parses an HTTP response from a AllWithResponse call
func ParseAllResponse(rsp *http.Response) (*AllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PairInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAllByGroupsResponse parses an HTTP response from a AllByGroupsWithResponse call
func ParseAllByGroupsResponse(rsp *http.Response) (*AllByGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllByGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllGroupOfPairs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAllByGroupsMetadataResponse parses an HTTP response from a AllByGroupsMetadataWithResponse call
func ParseAllByGroupsMetadataResponse(rsp *http.Response) (*AllByGroupsMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllByGroupsMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllGroupOfPairsMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAllWithPaginationResponse parses an HTTP response from a AllWithPaginationWithResponse call
func ParseAllWithPaginationResponse(rsp *http.Response) (*AllWithPaginationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AllWithPaginationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllPairsWithPagination
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSingleGroupPairResponse parses an HTTP response from a GetSingleGroupPairWithResponse call
func ParseGetSingleGroupPairResponse(rsp *http.Response) (*GetSingleGroupPairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSingleGroupPairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PairInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPairResponse parses an HTTP response from a GetPairWithResponse call
func ParseGetPairResponse(rsp *http.Response) (*GetPairResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPairResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PairInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBinTradeVolumeByDaysResponse parses an HTTP response from a GetBinTradeVolumeByDaysWithResponse call
func ParseGetBinTradeVolumeByDaysResponse(rsp *http.Response) (*GetBinTradeVolumeByDaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBinTradeVolumeByDaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BinTradeVolume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPairFeeBpsByDaysResponse parses an HTTP response from a GetPairFeeBpsByDaysWithResponse call
func ParseGetPairFeeBpsByDaysResponse(rsp *http.Response) (*GetPairFeeBpsByDaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPairFeeBpsByDaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PairFeeBps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPairDailyTradeVolumeByDaysResponse parses an HTTP response from a GetPairDailyTradeVolumeByDaysWithResponse call
func ParseGetPairDailyTradeVolumeByDaysResponse(rsp *http.Response) (*GetPairDailyTradeVolumeByDaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPairDailyTradeVolumeByDaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PairTradeVolume
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPairTvlByDaysResponse parses an HTTP response from a GetPairTvlByDaysWithResponse call
func ParseGetPairTvlByDaysResponse(rsp *http.Response) (*GetPairTvlByDaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPairTvlByDaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PairTvlSnapshotByDay
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPairSwapRecordsResponse parses an HTTP response from a GetPairSwapRecordsWithResponse call
func ParseGetPairSwapRecordsResponse(rsp *http.Response) (*GetPairSwapRecordsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPairSwapRecordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Swap
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBinArraysResponse parses an HTTP response from a GetBinArraysWithResponse call
func ParseGetBinArraysResponse(rsp *http.Response) (*GetBinArraysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBinArraysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BinArrayCache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPositionResponse parses an HTTP response from a GetPositionWithResponse call
func ParseGetPositionResponse(rsp *http.Response) (*GetPositionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PositionWithApy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClaimFeesResponse parses an HTTP response from a GetClaimFeesWithResponse call
func ParseGetClaimFeesResponse(rsp *http.Response) (*GetClaimFeesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClaimFeesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClaimFee
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClaimRewardsResponse parses an HTTP response from a GetClaimRewardsWithResponse call
func ParseGetClaimRewardsResponse(rsp *http.Response) (*GetClaimRewardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClaimRewardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClaimReward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDepositsResponse parses an HTTP response from a GetDepositsWithResponse call
func ParseGetDepositsResponse(rsp *http.Response) (*GetDepositsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDepositsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DepositWithdraw
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRecentNSnapshotResponse parses an HTTP response from a GetRecentNSnapshotWithResponse call
func ParseGetRecentNSnapshotResponse(rsp *http.Response) (*GetRecentNSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecentNSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PositionSnapshot
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWithdrawsResponse parses an HTTP response from a GetWithdrawsWithResponse call
func ParseGetWithdrawsResponse(rsp *http.Response) (*GetWithdrawsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWithdrawsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DepositWithdraw
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPositionV2Response parses an HTTP response from a GetPositionV2WithResponse call
func ParseGetPositionV2Response(rsp *http.Response) (*GetPositionV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPositionV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Position
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWalletEarningResponse parses an HTTP response from a GetWalletEarningWithResponse call
func ParseGetWalletEarningResponse(rsp *http.Response) (*GetWalletEarningResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWalletEarningResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WalletEarning
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"HmcE2jCDh4f/BQAA//+nBLL5/XYAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
